<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legatio Finance - Immobilier Tokenisé & RWA dès 100$</title>
    <!-- Autres balises meta et styles inchangés -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js" type="text/javascript"></script>
    <!-- Styles inchangés -->
</head>
<body>
    <!-- Sections précédentes inchangées -->

    <div class="container">
        <!-- Autres sections inchangées -->

        <div class="section crypto-prices">
            <h2>Prix en Direct</h2>
            <p id="btcPrice">Bitcoin: Chargement...</p>
            <p id="goldPrice">Or: Chargement...</p>
            <p id="silverPrice">Argent: Chargement...</p>
        </div>

        <!-- Autres sections inchangées -->
    </div>

    <!-- Script mis à jour -->
    <script>
        let livePrices = {
            'bitcoin': 0,
            'pax-gold': 0,
            'silver-token-xagx': 0, // Remplacement de slv-token par silver-token-xagx
            'immobilier': 1000
        };

        async function fetchLivePrices() {
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,pax-gold,silver-token-xagx&vs_currencies=usd');
                const data = await response.json();
                
                // Récupération et validation des prix
                livePrices['bitcoin'] = data['bitcoin']?.usd || 0;
                livePrices['pax-gold'] = data['pax-gold']?.usd || 0;
                livePrices['silver-token-xagx'] = data['silver-token-xagx']?.usd || 0;

                // Log pour débogage
                console.log('Prix récupérés de CoinGecko:', livePrices);

                // Vérification spécifique pour l'argent
                if (livePrices['silver-token-xagx'] === 0) {
                    console.warn("Prix de silver-token-xagx non disponible. Vérifiez si le token est listé sur CoinGecko.");
                }

                updatePriceDisplay();
            } catch (error) {
                console.error('Erreur lors de la récupération des prix:', error);
                document.getElementById('btcPrice').textContent = 'Bitcoin: Prix indisponible';
                document.getElementById('goldPrice').textContent = 'Or: Prix indisponible';
                document.getElementById('silverPrice').textContent = 'Argent: Prix indisponible';
            }
        }

        function updatePriceDisplay() {
            document.getElementById('btcPrice').textContent = livePrices['bitcoin'] === 0 
                ? 'Bitcoin: Prix indisponible' 
                : `Bitcoin: $${livePrices['bitcoin'].toLocaleString('fr-FR', { maximumFractionDigits: 2 })}`;
            document.getElementById('goldPrice').textContent = livePrices['pax-gold'] === 0 
                ? 'Or: Prix indisponible' 
                : `Or: $${livePrices['pax-gold'].toLocaleString('fr-FR', { maximumFractionDigits: 2 })} / oz`;
            document.getElementById('silverPrice').textContent = livePrices['silver-token-xagx'] === 0 
                ? 'Argent: Prix indisponible' 
                : `Argent: $${livePrices['silver-token-xagx'].toLocaleString('fr-FR', { maximumFractionDigits: 2 })} / oz`;
            
            // Animation GSAP pour un effet fluide
            gsap.from(".crypto-prices p", { opacity: 0, duration: 0.5, stagger: 0.1 });
            updateCollateralPrice();
        }

        function updateCollateralPrice() {
            const collateralType = document.getElementById('collateral-type').value;
            const price = livePrices[collateralType] || 0;
            document.getElementById('collateral-price').textContent = price === 0 
                ? '$Prix indisponible' 
                : `$${price.toLocaleString('fr-FR', { maximumFractionDigits: 2 })}`;
        }

        function calculateLoan() {
            const collateralType = document.getElementById('collateral-type').value;
            const collateralAmount = parseFloat(document.getElementById('collateral-amount').value) || 0;
            const loanDuration = parseFloat(document.getElementById('loan-duration').value) || 0;
            const interestRate = parseFloat(document.getElementById('interest-rate').value) || 0;
            const collateralValue = collateralAmount * livePrices[collateralType];
            const ltv = 0.7;
            const loanAmount = collateralValue * ltv;
            const monthlyInterestRate = interestRate / 100 / 12;
            const monthlyPayment = (loanAmount * monthlyInterestRate) / (1 - Math.pow(1 + monthlyInterestRate, -loanDuration));
            const totalPayment = monthlyPayment * loanDuration;
            const totalInterest = totalPayment - loanAmount;

            document.getElementById('ltv-value').textContent = `${(ltv * 100).toFixed(0)}%`;
            const resultsDiv = document.getElementById('loan-results');
            if (collateralAmount > 0 && loanDuration > 0 && interestRate > 0) {
                resultsDiv.innerHTML = `
                    <p><strong>Montant du prêt :</strong> $${loanAmount.toLocaleString('fr-FR', { maximumFractionDigits: 2 })}</p>
                    <p><strong>Paiement mensuel :</strong> $${monthlyPayment.toLocaleString('fr-FR', { maximumFractionDigits: 2 })}</p>
                    <p><strong>Total des intérêts :</strong> $${totalInterest.toLocaleString('fr-FR', { maximumFractionDigits: 2 })}</p>
                    <p><strong>Total à rembourser :</strong> $${totalPayment.toLocaleString('fr-FR', { maximumFractionDigits: 2 })}</p>
                `;
                document.getElementById('loan-request-btn').classList.remove('hidden');
            } else {
                resultsDiv.innerHTML = '<p style="color: red;">Veuillez remplir tous les champs correctement.</p>';
                document.getElementById('loan-request-btn').classList.add('hidden');
            }
        }

        async function connectMetaMask() {
            const connectButton = document.getElementById('connect-metamask');
            const loadingSpinner = document.getElementById('loading-spinner');
            const walletAddress = document.getElementById('wallet-address');
            const networkStatus = document.getElementById('network-status');
            const errorMessage = document.getElementById('error-message');

            // Réinitialiser les messages
            walletAddress.classList.add('hidden');
            networkStatus.classList.add('hidden');
            errorMessage.classList.add('hidden');

            // Vérification de MetaMask
            if (!window.ethereum) {
                console.error("MetaMask non détecté : window.ethereum est undefined");
                errorMessage.classList.remove('hidden');
                errorMessage.textContent = "MetaMask n’est pas détecté. Veuillez vérifier que l’extension est installée et activée.";
                return;
            }

            if (!window.ethereum.isMetaMask) {
                console.error("L'objet window.ethereum n'est pas MetaMask");
                errorMessage.classList.remove('hidden');
                errorMessage.textContent = "L’extension détectée n’est pas MetaMask. Veuillez utiliser MetaMask.";
                return;
            }

            try {
                loadingSpinner.classList.remove('hidden');
                connectButton.disabled = true;

                // Ajouter un délai pour s'assurer que MetaMask est prêt
                console.log("Préparation de la connexion à MetaMask...");
                await new Promise(resolve => setTimeout(resolve, 100));

                // Vérifier les comptes existants avant de faire une nouvelle demande
                console.log("Vérification des comptes existants...");
                let accounts = await window.ethereum.request({ method: 'eth_accounts' });
                console.log("Comptes détectés via eth_accounts :", accounts);

                if (accounts.length === 0) {
                    console.log("Aucun compte détecté. Demande de connexion via eth_requestAccounts...");
                    accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    console.log("Comptes retournés par eth_requestAccounts :", accounts);
                }

                if (accounts.length === 0) {
                    throw new Error("Aucun portefeuille actif trouvé ou autorisation refusée.");
                }

                const account = accounts[0];
                walletAddress.classList.remove('hidden');
                walletAddress.textContent = `Adresse connectée : ${account.slice(0, 6)}...${account.slice(-4)}`;

                // Vérification du réseau (Arbitrum One : 0xa4b1)
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                console.log("Chain ID détecté :", chainId);
                if (chainId !== '0xa4b1') {
                    networkStatus.classList.remove('hidden');
                    networkStatus.textContent = 'Veuillez passer au réseau Arbitrum pour continuer.';
                    walletAddress.classList.add('hidden');
                } else {
                    networkStatus.classList.add('hidden');
                    connectButton.textContent = 'MetaMask Connecté';
                }
            } catch (error) {
                console.error('Erreur détaillée lors de la connexion à MetaMask:', error);
                errorMessage.classList.remove('hidden');
                if (error.code === 4001) {
                    errorMessage.textContent = 'Connexion refusée : Vous avez annulé la demande de connexion.';
                } else if (error.code === -32002) {
                    errorMessage.textContent = 'Une demande de connexion est déjà en cours. Vérifiez MetaMask et acceptez la demande.';
                    setTimeout(() => connectMetaMask(), 1000);
                } else if (error.message.includes("Aucun portefeuille actif trouvé") || error.message.includes("User denied account authorization")) {
                    errorMessage.textContent = 'Aucun portefeuille actif trouvé. Veuillez déverrouiller MetaMask, accepter la demande de connexion dans le pop-up, ou importer un portefeuille.';
                } else {
                    errorMessage.textContent = `Erreur : ${error.message || 'Problème inconnu lors de la connexion à MetaMask.'} Consultez la console pour plus de détails.`;
                }
            } finally {
                loadingSpinner.classList.add('hidden');
                connectButton.disabled = false;
            }
        }

        async function swapLEG() {
            if (document.getElementById('connect-metamask').textContent !== 'MetaMask Connecté') {
                alert('Connectez d’abord votre wallet !');
                return;
            }
            const amount = document.getElementById('swap-amount').value;
            document.getElementById('swap-result').textContent = `Échange de ${amount} ETH en cours... (API à implémenter)`;
            // À implémenter : appel à une API comme 0x ou Uniswap
        }

        function requestLoan() {
            const connectButton = document.getElementById('connect-metamask');
            if (connectButton.textContent === 'MetaMask Connecté') {
                alert('Demande de prêt initiée ! Vérifiez votre portefeuille MetaMask pour confirmer la transaction.');
            } else {
                alert('Veuillez connecter MetaMask avant de demander un prêt.');
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            fetchLivePrices();
            setInterval(() => { fetchLivePrices(); updatePriceDisplay(); }, 60000);
            document.getElementById('collateral-type').addEventListener('change', updateCollateralPrice);
            updateCollateralPrice();
            document.getElementById('connect-metamask').addEventListener('click', connectMetaMask);

            gsap.from(".section", { opacity: 0, y: 50, duration: 1, stagger: 0.3, scrollTrigger: { trigger: ".section", start: "top 90%", toggleActions: "play none none reverse" } });
            const buttons = document.querySelectorAll('.cta-button');
            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    gsap.to(button, { scale: 1.1, duration: 0.3, yoyo: true });
                });
            });

            document.querySelector('.back-to-top').addEventListener('click', () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });

            const modal = document.getElementById('demo-modal');
            const openModalBtn = document.getElementById('open-demo-modal');
            const closeModalBtn = document.getElementById('close-demo-modal');
            const form = document.getElementById('demo-form');
            const formMessage = document.getElementById('form-message');

            openModalBtn.addEventListener('click', (e) => {
                e.preventDefault();
                modal.style.display = 'block';
                gsap.fromTo(modal, { opacity: 0, scale: 0.9 }, { opacity: 1, scale: 1, duration: 0.3 });
            });

            closeModalBtn.addEventListener('click', () => {
                gsap.to(modal, { opacity: 0, scale: 0.9, duration: 0.3, onComplete: () => {
                    modal.style.display = 'none';
                    formMessage.style.display = 'none';
                    form.reset();
                } });
            });

            window.addEventListener('click', (e) => {
                if (e.target === modal) {
                    gsap.to(modal, { opacity: 0, scale: 0.9, duration: 0.3, onComplete: () => {
                        modal.style.display = 'none';
                        formMessage.style.display = 'none';
                        form.reset();
                    } });
                }
            });

            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                const formData = new FormData(form);
                try {
                    const response = await fetch(form.action, {
                        method: 'POST',
                        body: formData,
                        headers: { 'Accept': 'application/json' }
                    });
                    if (response.ok) {
                        formMessage.style.display = 'block';
                        formMessage.style.color = '#2c3e50';
                        formMessage.textContent = 'Merci ! Nous vous contacterons bientôt.';
                        form.reset();
                    } else {
                        formMessage.style.display = 'block';
                        formMessage.style.color = '#e74c3c';
                        formMessage.textContent = 'Une erreur s’est produite. Veuillez réessayer.';
                    }
                } catch (error) {
                    formMessage.style.display = 'block';
                    formMessage.style.color = '#e74c3c';
                    formMessage.textContent = 'Une erreur s’est produite. Veuillez réessayer.';
                }
            });

            document.getElementById('subscribe-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const formData = new FormData(e.target);
                const subscribeMessage = document.getElementById('subscribe-message');
                try {
                    const response = await fetch(e.target.action, {
                        method: 'POST',
                        body: formData,
                        headers: { 'Accept': 'application/json' }
                    });
                    if (response.ok) {
                        subscribeMessage.style.display = 'block';
                        subscribeMessage.textContent = 'Merci ! Vous êtes inscrit.';
                        e.target.reset();
                    } else {
                        const errorData = await response.json().catch(() => ({ error: `Erreur HTTP ${response.status}: ${response.statusText}` }));
                        console.error('Erreur Formspree:', errorData);
                        subscribeMessage.style.display = 'block';
                        subscribeMessage.style.color = '#e74c3c';
                        subscribeMessage.textContent = `Erreur : ${errorData.error || `Code ${response.status} - ${response.statusText}. Vérifiez votre compte Formspree.`}`;
                    }
                } catch (error) {
                    console.error('Erreur réseau ou CORS:', error);
                    subscribeMessage.style.display = 'block';
                    subscribeMessage.style.color = '#e74c3c';
                    subscribeMessage.textContent = `Erreur : ${error.message || 'Problème de connexion. Vérifiez la console.'}`;
                }
            });
        });
    </script>
</body>
</html>
